= Choosing collision shapes
:item: &rarr;
:url-api: https://stephengold.github.io/Minie/minie/javadoc/com/jme3/bullet
:url-enwiki: https://en.wikipedia.org/wiki

A _collision shape_
describes the shape and size of a collision object such as a rigid body.
The examples so far have all used spheres and/or cubes.
However, there are actually 16 subclasses of
{url-api}/collision/shapes/CollisionShape.html[`CollisionShape`].
Here they are in lexicographic order,
with key characteristics and illustrations:

[cols="2*",grid="none"]
|===

|1. {url-api}/collision/shapes/Box2dShape.html[`Box2dShape`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:box2d.png[height=160]

|2. {url-api}/collision/shapes/BoxCollisionShape.html[`BoxCollisionShape`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/My74h2Q.png[height=160]

|3. {url-api}/collision/shapes/CapsuleCollisionShape.html[`CapsuleCollisionShape`]

{item} convex +
{item} zero margin +
{item} precise +
{item} uniform scaling only
|image:https://i.imgur.com/R9NMEwc.png[height=160]

|4. {url-api}/collision/shapes/CompoundCollisionShape.html[`CompoundCollisionShape`]

{item} neither concave nor convex +
{item} positive margin +
{item} precise if-and-only-if all of its children are precise +
{item} scalable to the extent that all of its children are scalable
|image:https://i.imgur.com/gL6rgAA.png[height=160]

|5. {url-api}/collision/shapes/ConeCollisionShape.html[`ConeCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} uniform scaling only
|image:https://i.imgur.com/jZFVxQd.png[height=160]

|6. {url-api}/collision/shapes/Convex2dShape.html[`Convex2dShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} scalable to the extent that its base shape is scalable
|image:convex2d.png[height=160]

|7. {url-api}/collision/shapes/CylinderCollisionShape.html[`CylinderCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} limited scalability
|image:https://i.imgur.com/ey249X8.png[height=160]

|8. {url-api}/collision/shapes/EmptyShape.html[`EmptyShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable, but why bother?
|(no image)

|9. {url-api}/collision/shapes/GImpactCollisionShape.html[`GImpactCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/TOLRsig.png[height=160]

|10. {url-api}/collision/shapes/HeightfieldCollisionShape.html[`HeightfieldCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/JwtpqOM.png[height=160]

|11. {url-api}/collision/shapes/HullCollisionShape.html[`HullCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} fully scalable
|image:https://i.imgur.com/Rf61rcw.png[height=160]

|12. {url-api}/collision/shapes/MeshCollisionShape.html[`MeshCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/glB3Ujk.png[height=160]

|13. {url-api}/collision/shapes/MultiSphere.html[`MultiSphere`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/nTZEc8C.png[height=160]

|14. {url-api}/collision/shapes/PlaneCollisionShape.html[`PlaneCollisionShape`]

{item} concave and infinite +
{item}  positive margin +
{item}  precise +
{item}  fully scalable, but why bother?
|image:plane.png[height=160]

|15. {url-api}/collision/shapes/SimplexCollisionShape.html[`SimplexCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} not scalable
|image:https://i.imgur.com/l1fYSfc.png[height=160]

|16. {url-api}/collision/shapes/SphereCollisionShape.html[`SphereCollisionShape`]

{item} convex +
{item} zero margin +
{item} precise +
{item} uniform scaling only
|image:https://i.imgur.com/OPYrxRe.png[height=160]

|===

NOTE: In this context,
_concave_ doesn't imply that the shape in question must be
{url-enwiki}/Convex_set#Non-convex_set[non-convex in the mathematical sense].
Rather, it is a property of specific `CollisionShape` subclasses.

== Suitability for dynamic bodies

Not all collision shapes are suitable for dynamic rigid bodies.

In particular, the following shapes are suitable *only*
for kinematic or static collision objects because
Bullet cannot calculate their mass distributions:

* `EmptyShape`
* `HeightfieldCollisionShape`
* `MeshCollisionShape`
* `PlaneCollisionShape`

Furthermore,
collision detection doesn't work well between zero-thickness shapes:

* `Box2dShape`
* `Convex2dShape`
* `SimplexCollisionShape` with 1-3 vertices

There are many non-symmetric shapes
that can be applied to dynamic rigid bodies.
With such shapes, however, care should be taken to ensure
that the center and principal axes are reasonable:

* `CompoundCollisionShape`
* `GImpactCollisionShape`
* `HullCollisionShape`
* `MultiSphere`
* `SimplexCollisionShape` with 4 vertices

At the very least,
the shape's center should be located *inside* its convex hull.

The safest shapes for dynamic rigid bodies are the _primitives_,
since their centers and principal axes are known:

* `BoxCollisionShape`
* `CapsuleCollisionShape`
* `ConeCollisionShape`
* `CylinderCollisionShape`
* `SphereCollisionShape`

== Margin

All collision shapes except `CapsuleCollisionShape` and `SphereCollisionShape`
incorporate a _collision margin_.
According to the Bullet Manual, the purpose of margin is
"to improve performance and reliability of the collision detection."

For all shapes with margin, the default margin is 0.04 physics-space units.
Methods are provided to adjust their margins, but doing so is not recommended.

== Precise shapes

A _precise shape_ is a collision shape whose effective shape
(as determined by collisions, contact tests, ray tests, and sweep tests)
is unaffected by margin.

While most of the `CollisionShape` subtypes are precise,
there are 5 that are not.
For 4 of them, margin simply bloats their effective shapes:

* `ConeCollisionShape`
* `Convex2dShape`
* `HullCollisionShape`
* `SimplexCollisionShape`

Margin also distorts a `CylinderCollisionShape`,
but its effect on size is more complicated.

Since margin is defined in physics-space units,
its distortions are most noticeable for small shapes.

When using imprecise shapes, you may want to compensate for margin
by shrinking the shape's dimensions
(for a `ConeCollisionShape` or `CylinderCollisionShape`)
or by moving its defining vertices inward
(for a `SimplexCollisionShape` or `HullCollisionShape`).

Another possible workaround would be to scale the physics space so that
the effects of margin become less obvious.

=== Scaling

Some applications require collision shapes that are _scalable_
(can be dynamically shrunk or enlarged).
However, not all collision shapes can scale arbitrarily.
In particular:

* `SimplexCollisionShape` doesn't support scaling at all;
  the only allowed scaling is (1,1,1).
* `CapsuleCollisionShape`, `ConeCollisionShape`, and `SphereCollisionShape`
  support only uniform scaling, where all axes have the same scale factor.
  For instance, (0.2,0.2,0.2) or (9,9,9).
* `CylinderCollisionShape` allows the height and base to scale independently,
  but the scale factors of both base axes must be equal.
  In other words, the cross section must remain circular.
  So (9,9,9) would be allowed for any cylinder,
  but (9,1,1) would be allowed only for cylinders
  where the local X axis is the height axis.

You can test at runtime whether a particular scaling
is applicable to particular shape:

[source,java]
----
if (shape.canScale(newScale)) {
    shape.setScale(newScale);
}
----

== Choosing a shape

For efficient simulation, the general rule is:
"Use the simplest shape that yields the desired *behavior*."
By focusing on behavior rather than appearance,
you may avoid modeling details that don't matter.
For instance:

* If a glass bottle stays sealed, its collision shape need not be hollow.
* A character's hair should probably be omitted from their collision shape.
* Any small shape that only encounters large, flat surfaces
  can probably be approximated by a convex hull.

Because jMonkeyEngine models are composed of triangular meshes,
beginners are often tempted to use mesh-based shapes
(such as `GImpactCollisionShape`) for everything.
However, since mesh-based collision detection is CPU-intensive, primitive
convex shapes (such as boxes and spheres) are usually a better choice, even
when they don't match the model's shape exactly.
In particular, `CapsuleCollisionShape` is often used with humanoid models.

The following pseudo-code algorithm may be helpful:

----
if (the object doesn't move and isn't involved in collisions) {
    use an EmptyShape or don't add the object to the space
} else if (the object doesn't move
           and its shape can be approximated by an infinite plane) {
    use a PlaneCollisionShape
} else if (the object doesn't move
          and its shape can be approximated by point, line segment, or triangle) {
    use a SimplexCollisionShape
} else if (the object doesn't move
           and its shape can be approximated by rectangle) {
    use a Box2dShape
} else if (the object doesn't move
           and its shape can be approximated by 2-D convex polygon) {
    use a Convex2dShape
} else if (its shape can be approximated by a tetrahedron) {
    use a SimplexCollisionShape
} else if (its shape can be approximated by a centered sphere) {
    use a SphereCollisionShape
} else if (its shape can be approximated by a centered rectangular solid) {
    use a BoxCollisionShape
} else if (its shape can be approximated by a centered capsule) {
    use a CapsuleCollisionShape
} else if (its shape can be approximated by a centered cylinder) {
    use a CylinderCollisionShape
} else if (its shape can be approximated by a centered cone) {
    use a ConeCollisionShape
} else if (its shape can be approximated by an ellipsoid
           or an eccentric sphere
           or an eccentric capsule
           or the convex hull of multiple spheres) {
    use a MultiSphere
} else if (its shape can be approximated by an eccentric primitive
           or a combination of convex primitives) {
    use a CompoundCollisionShape
} else if (the object does not move) {
    if (it is a 2-D heightfield) {
        use a HeightfieldCollisionShape
    } else {
        use a MeshCollisionShape
    }
} else { // if the object moves
    if (its shape can be approximated by a convex hull) {
        use a HullCollisionShape
    } else if (its shape can be decomposed into convex hulls) {
        use a compound of hull shapes
    } else {
        use a GImpactCollisionShape
    }
}
----

(Pseudocode adapted from the flowchart on page 13 of
https://github.com/bulletphysics/bullet3/blob/master/docs/Bullet_User_Manual.pdf[the Bullet User Manual].)

NOTE: `GImpactCollisionShape` should be your last resort!

== Convex decomposition

Faced with simulating a non-convex object such as a ring,
the it's best to decompose it into convex shapes that,
when recombined, will approximate the desired behavior.

There are various approaches,
depending on what the developer knows about the object's shape.
If the object's mesh is generated procedurally, it may be possible
to decompose it during the generation process.
Or if the object is modelled in Blender,
it may be practical to manually decompose it there
into meshes that are convex or nearly so.
In those cases, the desired compound shape can be generated using
`CollisionShapeFactory.createDynamicMeshShape()`.

For situations where manual decomposition is impractical,
Minie incorporates Khaled Mamou's
https://github.com/kmammou/v-hacd[Volumetric-Hierarchical Approximate Convex Decomposition (V-HACD) algorithm].
V-HACD makes it easy to decompose a 3-D model into a
compound of hull shapes:

[source,java]
----
VHACDParameters parms = new VHACDParameters();
CollisionShape shape
        = CollisionShapeFactory.createVhacdShape(modelRoot, parms, null);
----

The V-HACD algorithm is costly to run, but in many applications it can
be run during in advance and stored in J3O format until needed.
During simulation, the resulting shape will usually be much more efficient
than a `GImpactCollisionShape`.

== Summary

* Minie provides 16 types of collision shapes,
  ranging from the trivial `EmptyShape` to the costly `GImpactCollisionShape`.
* Not all collision shapes are suitable for dynamic rigid bodies.
* When applying a non-symmetric shape to a dynamic rigid body,
  make sure that the center and principal axes are reasonable.
* Most collision shapes incorporate a margin, and in some cases the
  margin distorts the effective shape, making it imprecise.
* Most collision shapes can be scaled, but not all can be scaled non-uniformly.
* Use the simplest shape that yields the desired behavior.
* To speed up simulation of objects with non-convex shapes,
  decompose them into convex ones, either by hand or using V-HACD.

= Choosing collision shapes
:item: &rarr;
:url-api: https://stephengold.github.io/Minie/minie/javadoc/com/jme3/bullet

A _collision shape_
describes the shape and size of a collision object such as a rigid body.
The examples so far have all used spheres and cubes.
However, there are actually 16 subclasses of
{url-api}/collision/shapes/CollisionShape.html[`CollisionShape`].
Here they are in lexicographic order, with characteristics and illustrations:

[cols="2*",grid="none"]
|===

|1. {url-api}/collision/shapes/Box2dShape.html[`Box2dShape`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:box2d.png[height=160]

|2. {url-api}/collision/shapes/BoxCollisionShape.html[`BoxCollisionShape`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/My74h2Q.png[height=160]

|3. {url-api}/collision/shapes/CapsuleCollisionShape.html[`CapsuleCollisionShape`]

{item} convex +
{item} zero margin +
{item} precise +
{item} uniform scaling only
|image:https://i.imgur.com/R9NMEwc.png[height=160]

|4. {url-api}/collision/shapes/CompoundCollisionShape.html[`CompoundCollisionShape`]

{item} neither concave nor convex +
{item} positive margin +
{item} precise if-and-only-if all of its children are precise +
{item} scalable to the extent that all of its children are scalable
|image:https://i.imgur.com/gL6rgAA.png[height=160]

|5. {url-api}/collision/shapes/ConeCollisionShape.html[`ConeCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} uniform scaling only
|image:https://i.imgur.com/jZFVxQd.png[height=160]

|6. {url-api}/collision/shapes/Convex2dShape.html[`Convex2dShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} scalable to the extent that its base shape is scalable
|image:convex2d.png[height=160]

|7. {url-api}/collision/shapes/CylinderCollisionShape.html[`CylinderCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} limited scalability
|image:https://i.imgur.com/ey249X8.png[height=160]

|8. {url-api}/collision/shapes/EmptyShape.html[`EmptyShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable, but why bother?
|(no image)

|9. {url-api}/collision/shapes/GImpactCollisionShape.html[`GImpactCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/TOLRsig.png[height=160]

|10. {url-api}/collision/shapes/HeightfieldCollisionShape.html[`HeightfieldCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/JwtpqOM.png[height=160]

|11. {url-api}/collision/shapes/HullCollisionShape.html[`HullCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} fully scalable
|image:https://i.imgur.com/Rf61rcw.png[height=160]

|12. {url-api}/collision/shapes/MeshCollisionShape.html[`MeshCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/glB3Ujk.png[height=160]

|13. {url-api}/collision/shapes/MultiSphere.html[`MultiSphere`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/nTZEc8C.png[height=160]

|14. {url-api}/collision/shapes/PlaneCollisionShape.html[`PlaneCollisionShape`]

{item} concave and infinite +
{item}  positive margin +
{item}  precise +
{item}  fully scalable, but why bother?
|(no image yet)

|15. {url-api}/collision/shapes/SimplexCollisionShape.html[`SimplexCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} not scalable
|image:https://i.imgur.com/l1fYSfc.png[height=160]

|16. {url-api}/collision/shapes/SphereCollisionShape.html[`SphereCollisionShape`]

{item} convex +
{item} zero margin +
{item} precise +
{item} uniform scaling only
|image:https://i.imgur.com/OPYrxRe.png[height=160]

|===

== Limitations of particular subclasses

=== Suitability for dynamic rigid bodies

Not all collision shapes are suitable for dynamic rigid bodies.
In particular, the following shapes are suitable ONLY
for kinematic or static collision objects:

* `Box2dShape`
* `Convex2dShape`
* `EmptyShape`
* `HeightfieldCollisionShape`
* `MeshCollisionShape`
* `PlaneCollisionShape`
* `SimplexCollisionShape` with 1-3 vertices

(Simplex shapes with 4 vertices are fine for dynamic rigid bodies.)

=== Precision and margins

Most collision shapes incorporate a margin.
According to the Bullet Manual, the purpose of margin is
"to improve performance and reliability of the collision detection."

While methods are provided to adjust margins, doing so is not recommended.

For certain shapes, margin increases the effective size of the collision object
and distorts its effective shape:

* `ConeCollisionShape`
* `Convex2dShape`
* `HullCollisionShape`
* `SimplexCollisionShape`

Margin also distorts a `CylinderCollisionShape`,
but its effect on size is complicated.

Distortion due to margin is most noticeable for small shapes.

When using imprecise shapes, you can compensate somewhat for margin
by shrinking the shape's dimensions
(for a `ConeCollisionShape` or `CylinderCollisionShape`)
or moving its defining vertices inward
(for a `SimplexCollisionShape` or `HullCollisionShape`).

Another possible workaround is to scale the physics space so that
the effects of margin become less obvious.

If these workarounds are impractical,
use a "precise" shape, one that isn't distorted by margin:

* `Box2dShape`
* `BoxCollisionShape`
* `CapsuleCollisionShape`
* `GImpactCollisionShape`
* `HeightfieldCollisionShape`
* `MeshCollisionShape`
* `MultiSphere`
* `PlaneCollisionShape`
* `SphereCollisionShape`

=== Scalability

Some applications require collision shapes that are scalable
(can be dynamically shrunk or enlarged).
However, not all collision shapes can scale arbitrarily.
In particular,

* `SimplexCollisionShape` doesn't support scaling at all;
  the only allowed scaling is (1,1,1).
* `CapsuleCollisionShape`, `ConeCollisionShape`, and `SphereCollisionShape`
  support only uniform scaling, where all axes have the same scale factor.
  For instance, (0.2,0.2,0.2) or (9,9,9).
* `CylinderCollisionShape` allows the height and base to scale independently,
  but the scale factors of both base axes must be equal.
  In other words, the cross section must remain circular.
  So (9,9,9) would be allowed for any cylinder,
  but (9,1,1) would be allowed only for cylinders
  where the local X axis is the height axis.

You can test at runtime whether a particular scaling
is applicable to particular shape:

[source,java]
----
if (shape.canScale(newScale)) {
    shape.setScale(newScale);
}
----

== An algorithm for choosing a shape

For efficient simulation, the general rule is:
"Use the simplest shape that yields the desired behavior."
By staying focused on behavior, you avoid modeling details that don't matter.
For instance:

* If a glass bottle stays sealed, its collision shape need not be hollow.
* A character's hair probably shouldn't be included in their collision shape.
* Any small shape that encounters only large, flat surfaces
  can probably be approximated by a convex hull.

Because jMonkeyEngine models are composed of triangular meshes,
beginners are often tempted to use mesh-based shapes
(such as `GImpactCollisionShape`) for everything.
However, since mesh-based collision detection is CPU-intensive, primitive
convex shapes (such as boxes and spheres) are usually a better choice, even
if they don't match the model's shape exactly.
In particular, `CapsuleCollisionShape` is often used with humanoid models.

----
if (the object doesn't move and isn't involved in collisions) {
    use an EmptyShape or don't add the object to the space
} else if (the object doesn't move and its shape can be approximated by an infinite plane) {
    use a PlaneCollisionShape
} else if (the object doesn't move and its shape can be approximated by point, line segment, or triangle) {
    use a SimplexCollisionShape
} else if (the object doesn't move and its shape can be approximated by rectangle) {
    use a Box2dShape
} else if (the object doesn't move and its shape can be approximated by convex polygon) {
    use a Convex2dShape
} else if (its shape can be approximated by a tetrahedron) {
    use a SimplexCollisionShape
} else if (its shape can be approximated by a centered sphere) {
    use a SphereCollisionShape
} else if (its shape can be approximated by a centered rectangular solid) {
    use a BoxCollisionShape
} else if (its shape can be approximated by a centered capsule) {
    use a CapsuleCollisionShape
} else if (its shape can be approximated by a centered cylinder) {
    use a CylinderCollisionShape
} else if (its shape can be approximated by a centered cone) {
    use a ConeCollisionShape
} else if (its shape can be approximated by an ellipsoid
            or an eccentric sphere
            or an eccentric capsule
            or the convex hull of multiple spheres) {
    use a MultiSphere
} else if (its shape can be approximated by an eccentric rectangular solid
            or an eccentric cylinder
            or an eccentric cone
            or a combination of convex primitives) {
    use a CompoundCollisionShape
} else if (the object does not move) {
    if (it is a 2-D heightfield) {
        use a HeightfieldCollisionShape
    } else {
        use a MeshCollisionShape
    }
} else { // if the object moves
    if (its shape can be approximated by a convex hull) {
        use a HullCollisionShape
    } else if (its shape can be decomposed into convex hulls) {
        use a compound of hull shapes
    } else {
        use a GImpactCollisionShape
    }
}
----

(Pseudocode adapted from the flowchart on page 13 of
https://github.com/bulletphysics/bullet3/blob/master/docs/Bullet_User_Manual.pdf[the Bullet User Manual].)

NOTE: `GImpactCollisionShape` should be your last resort!

Minie has Khaled Mamou's Volumetric-Hierarchical Approximate Convex
Decomposition (V-HACD) algorithm built in.
V-HACD makes it easy to decompose any 3-D model into a
compound of hull shapes:

[source,java]
----
VHACDParameters parms = new VHACDParameters();
CollisionShape shape
        = CollisionShapeFactory.createVhacdShape(modelRoot, parms, null);
----

The V-HACD algorithm is costly to run, but in many applications it can
be run during the build process and stored in J3O format.
At runtime, the resulting shape will usually be far more efficient
than a `GImpactCollisionShape`.

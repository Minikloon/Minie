= An introduction to rigid-body physics
:experimental:
:page-toclevels: 3
:url-examples: https://github.com/stephengold/Minie/blob/master/MinieExamples/src/main/java/jme3utilities
:url-tutorial: https://github.com/stephengold/Minie/blob/master/MinieExamples/src/main/java/jme3utilities/tutorial

== Five familiar features

A _rigid body_ is a type of collision object
that exhibits some familiar features of real-world objects, including:

* _rigidity_ (a fixed shape) and
* _inertia_ (resistance to change of motion).

The simplest way to create a rigid body
is to directly invoke the `PhysicsRigidBody` constructor.
This allows you to specify its mass and collision shape.
Together, these properties determine its
https://en.wikipedia.org/wiki/Moment_of_inertia[_moment of inertia_]:

[source,java]
----
CollisionShape ballShape = new SphereCollisionShape(1f);
float ballMass = 2f;
PhysicsRigidBody ball = new PhysicsRigidBody(ballShape, ballMass);
Vector3f inertia = Vector3f.UNIT_XYZ.divide(ball.getInverseInertiaLocal(null));
----

By default, rigid bodies also exhibit 3 other features of real-world objects:

* They are _dynamic_
  (mobile, with their motion determined by
  https://en.wikipedia.org/wiki/Force[_forces_],
  https://en.wikipedia.org/wiki/Torque[_torques_], and
  https://en.wikipedia.org/wiki/Impulse_(physics)[_impulses_].)
* They are subject to _gravity_:
  a continual downward force proportional to their mass.
* They exhibit _contact response_:
  powerful forces which prevent them from intersecting with other bodies.

However, these last 3 features are optional and can be disabled.

=== HelloRigidBody

{url-tutorial}/HelloRigidBody.java[HelloRigidBody] is a simple
application that demonstrates the 5 familiar features of rigid bodies.
Things to notice while running the app:

. Two balls, both falling slowly under the influence of gravity.
. The ball on the right receives an impulse that pushes it leftward.
. After the impulse ends, the ball's inertia keeps it moving leftward.
. The simulation runs at one-tenth normal speed,
  making the individual time steps noticeable.
. The balls collide, generating contact forces
  that alter their motions but not their shapes.
.* The ball on the right loses half of its speed.
.* The ball on the left begins moving leftward as it falls.

== Configuring rigid bodies

=== Static rigid bodies

Not all rigid bodies are dynamic.
To create a _static_ (non-moving) rigid body,
specify `mass=0` in the constructor.
Unlike a dynamic body,
a static one is unaffected by forces, torques, and impulses,
as if its mass were infinite.

{url-tutorial}/HelloStaticBody.java[HelloStaticBody]
is a simple application that combines static and dynamic rigid bodies.
Things to notice while running the app:

. Two balls: the top one dynamic, the bottom one static.
. The balls collide, generating contact forces
  that alter the path of the dynamic ball.
. The static ball stays fixed in place,
  unaffected by both gravity and contact forces.

=== Position

Every rigid body occupies a _position_ in space, described by 2 properties:

* the _location_ of the body's center and
* the body's _orientation_,
  the rotation of its (local) axes relative to those of the physics space.

Each property can be configured separately:

[source,java]
----
body.setPhysicsLocation(new Vector3f(5f, 1f, 0f));
body.setPhysicsRotation(new Quaternion(0.5f, 0.5f, 0.5f, 0.5f));
----

NOTE: Once a dynamic or static body has been initialized,
it should never be repositioned in this manner.

The center of a dynamic body should be located at its
https://en.wikipedia.org/wiki/Center_of_mass[_center of mass_],
the location around which it tends to spin,
and its local axes should correspond to the
https://en.wikipedia.org/wiki/Principal_axis_(mechanics)[_principal axes_]
of its mass distribution.

Unlike a dynamic body, a static body allows complete flexibility
in the choice of center and local axes.

=== Kinematic flag

In addition to static and dynamic, there's a third type of rigid body.

_Kinematic_ bodies share properties of both static and dynamic ones.
Like dynamic bodies, kinematic ones can move.
However, they are unaffected by forces, torques, and impulses.
Their movement is driven by external logic, which may, if desired,
reposition them prior to every timestep.

In the presence of dynamic bodies, a kinematic body acts like
an unstoppable battering ram.

There's no way to instantiate a kinematic rigid body directly.
To convert a dynamic rigid body into a kinematic one, use `setKinematic(true)`.

For obscure reasons, a kinematic rigid body must have positive mass.
To convert a static rigid body into a kinematic one, set its mass
to a positive value *before* setting its kinematic flag:

[source,java]
----
body.setMass(1f);
body.setKinematic(true);
----

{url-tutorial}/HelloKinematics.java[HelloKinematics]
is a simple application that combines static and dynamic rigid bodies.
Things to notice while running the app:

. Two balls: the top one dynamic, the bottom one kinematic.
. The kinematic ball orbits a fixed point in space.
. The balls collide, generating contact forces
  that alter the motion of the dynamic ball.
. The kinematic ball continues to orbit,
  unaffected by both gravity and contact forces.

=== Contact response

When physics simulation detects a collision between
2 bodies that both have contact response, it applies contact forces.

To disable the contact response of a rigid body,
use `setContactResponse(false)`.

{url-tutorial}/HelloContactResponse.java[HelloContactResponse]
is a simple application demonstrates contact response.
Things to notice while running the app:

. The ball falls until it collides with the blue (static) box,
  which provides a contact force to halt its motion and counteract gravity.
. Press the spacebar to disable the ball's contact response.
. Afterwards, the box no longer exerts any force on the ball.
  Gravity takes over, and the ball falls through the box.

=== Velocity

Every dynamic body has a _velocity_, which quantifies its motion at the
present instant.

More precisely, it has 2 velocities: _linear velocity_ and _angular velocity_,
both represented as 3-D vectors.
The magnitude and direction of the linear velocity vector describe the speed
and direction at which its center is traveling through space (if at all).
The magnitude and direction of the angular velocity vector describe the
rate and axis of the body's spinning motion, if any.

NOTE: Both velocities of a static body are zero.

NOTE: Both velocities of a kinematic body are undefined.

To initialize the velocities of a dynamic rigid body,
use its `setLinearVelocity()` and `setAngularVelocity()` methods.

=== Built-in forces

Many familiar real-world phenomena
can be modeled as forces acting on rigid bodies.

You can apply custom forces using the following 6 methods:

* `applyCentralForce(Vector3f)`
* `applyCentralImpulse(Vector3f)`
* `applyForce(Vector3f force, Vector3f offset)`
* `applyImpulse(Vector3f impulse, Vector3f offset)`
* `applyTorque(Vector3f)`
* `applyTorqueImpulse(Vector3f)`

For convenience, the following forces are "built into" rigid body simulations:

* drag forces:
** damping
* gravity
* contact forces:
** restitution
** friction

==== Damping

In the absence of external forces,
inertia would keep the velocities of a dynamic body constant.
In the real world, however,
we're accustomed to seeing moving objects eventually come to rest.
This behavior can be caused by _drag forces_ (such as air resistance)
that increase with speed.

To simulate drag forces, each rigid body has _damping_,
which quantifies how quickly its motion decays to zero,
assuming the body is dynamic.

More precisely, each body has 2 damping parameters:
_linear damping_ and _angular damping_,
each of which ranges from zero (no drag) to one (motion ceases immediately).

Accessors are provided for both parameters, separately and together:

[source,java]
----
rigidBody.setAngularDamping(0.5f);  // default=0
rigidBody.setLinearDamping(0.2f);   // default=0
// or alternatively:
float linearDamping = 0.5f;
float angularDamping = 0.2f;
rigidBody.setDamping(linearDamping, angularDamping);
----

{url-tutorial}/HelloDamping.java[HelloDamping]
is a simple application that demonstrates damping.
Things to notice while running the app:

. Four cubes intially share the same linear and angular velocities.
. The top 2 have constant linear velocities, a sign of zero linear damping.
. The left 2 have constant angular velocities, a sign of zero angular damping.
. The linear velocities of the bottom 2 cubes decay quickly to zero
  due to strong linear damping.
. The angular velocities of the right 2 cubes decay quickly to zero
  due to strong angular damping.

==== Gravity

In the real world,
we're accustomed to seeing unsupported objects fall.
This behavior is caused by _gravity_,
a downward force that's proportional to mass.

To simulate this phenomenon, each body has a gravity vector,
which (if the body is dynamic) applies a continual downward force.
To configure a body's gravity, use `setGravity(accelerationVector)`.

NOTE: If following the Y-up convention, the X and Z components of the
vector should be zero, and its Y component should be *negative*.

When a body is added to a `PhysicsSpace`,
the gravity of the space typically gets applied to it,
replacing any previously configured gravity.
To protect a rigid body from gravity changes caused by the space
to which it's added, use `setProtectGravity(true)`.

To simulate a non-uniform gravitational field,
update the gravity of each body prior to each physics tick.

[source,java]
----
public void prePhysicsTick(PhysicsSpace space, float timeStep) {
    Collection<PhysicsCollisionObject> pcos = space.getPcoList();
    for (PhysicsCollisionObject pco : pcos) {
        if (pco instanceof PhysicsBody) {
            updateGravity((PhysicsBody) pco);
        }
    }
}
----

TODO non-u example app

==== Restitution

When 2 responsive rigid bodies collide,
contact forces come into play, altering their velocities.
These forces are split into 2 components:  restitution and friction.

_Restitution_ is a force perpendicular to the collision plane.
Its strength hints at what the bodies might be made out of.

If both bodies were made of hard, springy steel,
they might separate without loss of energy,
following what's called a _perfectly elastic_ collision.
If, on the other hand, both bodies were made of soft, sticky clay,
they might cling together,
resulting in what's called a _perfectly inelastic_ collision.

In reality, no collision is perfectly elastic.
Elasticity is quantified by a _coefficient of restitution_,
which ranges from zero (perfectly inelastic) to one (perfectly elastic).

In Minie and Bullet, collisions are inelastic by default.
(We saw this in {url-tutorial}/HelloRigidBody.java[HelloRigidBody.java].)
Each rigid body has a _restitution parameter_ which defaults to zero.
The coefficient of restitution is calculated by multiplying the parameters
of the colliding bodies.

To simulate a perfectly elastic collision, set the restitution parameters of
both bodies to one:

[source,java]
----
rigidBodyA.setRestitution(1f); // default=0
rigidBodyB.setRestitution(1f);
----

{url-examples}/NewtonsCradle.java[The Newton's Cradle demo]
demonstrates perfectly elastic collisions.
At startup, the simulation is paused.
Press kbd:[.] to start the simulation, or to pause it while running.

==== Friction

Just as restitution models the contact forces
perpendicular to the collision plane,
_friction_ models contact forces whose directions lie *in* the collision plane.

Each rigid body has a friction parameter (which defaults to 0.5),
and the coefficient of friction is determined by adding the parameters
of the colliding bodies.
A body's friction parameter hints at its surface characteristics.
To configure the parameter, use `setFriction(parameter)`.
Reducing a body's friction parameter makes it more slippery (think wet ice).
Increasing it results in better traction (think sandpaper or rubber).

TODO move the rest of this section to an advanced topic

Because friction can generate both forces and torques,
modeling it can get very complicated.

In addition to its basic friction parameter,
each rigid body also has 2 additional friction parameters:
one for rolling friction and one for spinning frction.
Both parameters default to zero.

_Rolling friction_ creates torque orthogonal to the contact normal,
which tends to slow down a rolling body.
_Spinning friction_ creates torque parallel to the contact normal,
which tends to prevent a body from spinning when grasped.

To see rolling and spinning friction in action, run
{url-examples}/PoolDemo.java[the PoolDemo application].

To simulate objects with grooved surfaces, it's also possible to configure
a body for _anisotropic friction_:
friction that depends on the direction of relative motion.

=== Related demo apps

{url-examples}/DropTest.java[The DropTest demo] and
{url-examples}/TargetDemo.java[the TargetDemo application]
allow and you to vary the damping, friction, gravity,
and restitution of all the bodies in a physics space.
This allows you to see how these 4 parameters affect the bodies' motion.

* Use kbd:[Enter] to add dynamic bodies to the space.
* Use kbd:[num8] and kbd:[num2] to select the desired parameter.
* Use kbd:[num4] and kbd:[num6] to cycle through the available parameter values.

== Sleeping and activation
TODO

== Continuous collision detection
TODO

== RigidBodyControl
TODO
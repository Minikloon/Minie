= An introduction to rigid-body physics
:url-tutorial: https://github.com/stephengold/Minie/blob/master/MinieExamples/src/main/java/jme3utilities/tutorial

A rigid body (instance of `PhysicsRigidBody`) is a type of collision object
that exhibits some familiar features of real-world objects, including:

* rigidity (a fixed shape) and
* inertia (resistance to changes in its motion).

When creating a rigid body directly, one can specify both its mass
and collision shape. Together, these properties determine its inertia:

[source,java]
----
CollisionShape ballShape = new SphereCollisionShape(1f);
float ballMass = 2f;
PhysicsRigidBody ball = new PhysicsRigidBody(ballShape, ballMass);
Vector3f inertia = Vector3f.UNIT_XYZ.divide(ball.getInverseInertiaLocal(null));
----

By default, rigid bodies also exhibit 3 more features of real-world objects:

* They are dynamic
  (mobile, with motion determined by forces, torques, and impulses.)
* They are subject to gravity:
  a continual downward force proportional to their mass.
* They exhibit contact response:
  a tendency to avoid intersecting with other bodies.

When physics simulation detects a collision between
2 responsive bodies, it applies powerful
"contact forces" in an attempt to separate them.

For a simple example demonstrating all 5 features of rigid bodies, see
{url-tutorial}/HelloRigidBody.java[HelloRigidBody.java].

== Configuring rigid bodies

To create a static (non-moving) rigid body, specify `mass=0` in the constructor.

For a simple example combining static and dynamic rigid bodies, see
{url-tutorial}/HelloStaticBody.java[HelloStaticBody.java].

=== Position

Every rigid body occupies a position in space, described by 2 properties:

* the location of the body's center and
* the rotation (orientation) of its local axes.

Both these properties can be independently configured:

[source,java]
----
body.setPhysicsLocation(new Vector3f(5f, 1f, 0f));
body.setPhysicsRotation(new Quaternion(0.5f, 0.5f, 0.5f, 0.5f));
----

Once a dynamic or static body has been initialized, of course,
it shouldn't be repositioned in this manner.
A kinematic (externally driven) body, on the other hand,
may be repositioned for every timestep.

The center of a dynamic body should be located at its
https://en.wikipedia.org/wiki/Center_of_mass[center of mass],
the point around which it tends to spin,
and its local axes should correspond to its
https://en.wikipedia.org/wiki/Principal_axis_(mechanics)[principal axes].

A static or kinematic body allows more flexibility
in the choice of its center and local axes.

=== Kinematic flag

To convert a dynamic rigid body into a kinematic one,
use `setKinematic(true)`.

For a simple example combining kinematic and dynamic rigid bodies, see
{url-tutorial}/HelloKinematics.java[HelloKinematics.java].

To convert a static rigid body into a kinematic one, set its mass
to a positive value *before* setting its kinematic flag:

[source,java]
----
body.setMass(1f);
body.setKinematic(true);
----

=== Contact response

To disable the contact response of a rigid body,
use `setContactResponse(false)`.

For a simple demonstration of this feature, see
{url-tutorial}/HelloContactResponse.java[HelloContactResponse.java].

The ball falls until it collides with the blue (static) box,
which provides a contact force to counteract gravity.
Press the spacebar to disable the ball's contact response.
Once this happens, the box no longer exerts any force on the ball.
Gravity takes over, and the ball falls through the box.

=== Velocity

Every dynamic body has a velocity, which quantifies how it is moving at the
present instant.

More precisely, it has 2 velocities: "linear velocity" and "angular velocity",
both represented as 3-D vectors.
The magnitude and direction of the linear velocity vector describe the speed
and direction at which its center is traveling through space, if at all.
The magnitude and direction of the angular velocity vector describe the
rate and axis of the body's spinning motion, if any.

* Both velocities of a static body are zero.
* The velocities of a kinematic body are undefined.

=== Damping

In the absence of external forces,
the velocities of a dynamic body would be constant.
However, we're accustomed to seeing moving objects eventually come to rest.
This behavior is partly caused by drag forces such as air resistance.

To simulate drag forces, each dynamic rigid body includes damping,
which quantifies how fast its motion (if any) decays.

More precisely, each body has 2 damping parameters:
"linear damping" and "angular damping",
each of which ranges from zero (no drag) to one (motion ceases).

Minie provides accessors for both parameters:

[source,java]
----
rigidBody.setAngularDamping(0.5f);  // default=0
rigidBody.setLinearDamping(0.2f);   // default=0
rigidBody.setDamping(linearDamping, angularDamping);
----

TODO tutorial app

=== Gravity

However, we're accustomed to seeing unsupported objects fall
under the influence of gravity.

To simulate this phenomenon, each body has a gravity vector,
which (if the body is dynamic) applies a continual downward acceleration.
To configure a body's gravity, use `setGravity(accelerationVector)`.
If following the Y-up convention, the X and Z components of the
vector should be zero, and its Y component should be *negative*.

When a body is added to a `PhysicsSpace`,
the gravity of the space typically gets applied to it,
replacing any previously configured gravity.
To protect a rigid body from gravity changes caused by the space
to which it's added, use `setProtectGravity(true)`.

To simulate a non-uniform gravitational field,
update the gravity of each body prior to each physics tick.

[source,java]
----
public void prePhysicsTick(PhysicsSpace space, float timeStep) {
    Collection<PhysicsCollisionObject> pcos = space.getPcoList();
    for (PhysicsCollisionObject pco : pcos) {
        if (pco instanceof PhysicsBody) {
            updateGravity((PhysicsBody) pco);
        }
    }
}
----

TODO non-u example app

=== Restitution

When bodies collide, contact forces come into play, altering their velocities.
Restitution is the contact force perpendicular to the collision plane.
Its strength depends on what the bodies are made out of.

If both bodies were composed of hard, springy steel,
they might separate without loss of energy,
after what's called a "perfectly elastic" collision.
If, on the other hand, both bodies were made of soft, sticky clay,
they might cling together,
resulting in what's called a "perfectly inelastic" collision.

In reality, no collision is perfectly elastic.
Elasticity is quantified by a "coefficient of restitution",
which ranges from zero (perfectly inelastic) to one (perfectly elastic).

In Minie and Bullet, collisions are perfectly inelastic by default.
(We saw this in {url-tutorial}/HelloRigidBody.java[HelloRigidBody.java].)
Each rigid body has a restitution parameter (which defaults to zero),
and the coefficient of restitution is determined by multiplying the parameters
of the colliding bodies.

To simulate a perfectly elastic collision, set the restitution parameters of
both bodies to one:

[source,java]
----
rigidBodyA.setRestitution(1f); // default=0
rigidBodyB.setRestitution(1f);
----

To see perfectly elastic collisions, run
https://github.com/stephengold/Minie/blob/master/MinieExamples/src/main/java/jme3utilities/NewtonsCradle.java[the Newton's Cradle demo].

=== Friction

Just as restitution models the component of the contact force
perpendicular to the collision plane,
friction models the component that lies *in* the plane.

Each rigid body has a friction parameter (which defaults to 0.5),
and the coefficient of friction is determined by adding the parameters
of the colliding bodies.
Reducing a body's friction parameter makes it more slippery (think wet ice).
Increasing it results in better traction (think sandpaper or rubber).

Modeling friction is more complicated than modeling restitution because
friction can generate both contact forces and contact torques.
In addition to its basic friction parameter,
each rigid body also has 2 additional friction parameters:
one for rolling friction and one for spinning frction.
Both parameters default to zero.

Rolling friction creates torque orthogonal to the contact normal,
which tends to slow down a rolling body.
Spinning friction creates torque parallel to the contact normal,
which tends to prevent a body from spinning when grasped.

Minie provides accessors for the 3 parameters described above:

[source,java]
----
rigidBody.setFriction(5f);          // default=0.5
rigidBody.setRollingFriction(10f);  // default=0
rigidBody.setSpinningFriction(50f); // default=0
----

Using numpad keys, you can vary the damping, friction, gravity,
and restitution of the dropped bodies in
https://github.com/stephengold/Minie/blob/master/MinieExamples/src/main/java/jme3utilities/NewtonsCradle.java[the DropTest demo]
and see how these parameters affect their motion.

To see rolling and spinning friction in action, run
https://github.com/stephengold/Minie/blob/master/MinieExamples/src/main/java/jme3utilities/PoolDemo.java[the PoolDemo application].

TODO contact damping/processing/stiffness, sleeping/activation, CCD, RigidBodyControl
